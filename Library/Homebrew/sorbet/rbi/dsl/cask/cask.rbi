# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for dynamic methods in `Cask::Cask`.
# Please instead update this file by running `bin/tapioca dsl Cask::Cask`.


class Cask::Cask
  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def app(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def appdir(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def arch(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def artifact(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def artifacts(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def audio_unit_plugin(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def auto_updates(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def autobump?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def bash_completion(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def binary(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def caveats(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def colorpicker(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def conflicts_with(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def container(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def depends_on(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def depends_on_set_in_block?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecate!(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def deprecated?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecation_date(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecation_reason(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecation_replacement_cask(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecation_replacement_formula(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def desc(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def dictionary(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable!(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable_date(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable_reason(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable_replacement_cask(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable_replacement_formula(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def disabled?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def discontinued?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def fish_completion(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def font(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def homepage(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def input_method(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def installer(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def internet_plugin(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def keyboard_layout(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def language(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def livecheck(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def livecheck_defined?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def livecheckable?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def manpage(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def mdimporter(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def name(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def no_autobump!(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def no_autobump_message(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.nilable(MacOSVersion)) }
  def on_system_block_min_os(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def on_system_blocks_exist?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def os(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def pkg(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def postflight(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def preflight(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def prefpane(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def qlplugin(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def screen_saver(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def service(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def sha256(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def stage_only(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def staged_path(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def suite(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def uninstall(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def uninstall_postflight(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def uninstall_preflight(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.nilable(::Cask::URL)) }
  def url(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def version(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def vst3_plugin(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def vst_plugin(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def zap(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def zsh_completion(*args, &block); end
end
